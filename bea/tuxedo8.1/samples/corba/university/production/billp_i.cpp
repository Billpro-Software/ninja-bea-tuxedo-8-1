//	(c) 2003 BEA Systems, Inc. All Rights Reserved. 
//--------------------------------------------------------------------
//
// billp_i.cpp
//
// C++ billing servant implementations for the university sample
// declaration.
//
// Classes implemented :
//
//   Teller_i
//   TellerFactory_i
//
// This file was originally generated by using the "-i" idl switch,
// then edited by hand.
//
// BEA Systems Inc. sample code
//
//--------------------------------------------------------------------

#include <log.h>
#include <unique_id.h>
#include <atmi.h>
#include <fml32.h>
#include <TP.h>
#include "tellp_flds.h"	// tux teller app fields
#include "billp_i.h"

//--------------------------------------------------------------------
// utility to call tux after the input buffer has been filled in
// if anything goes wrong, it throws a CORBA::PERSIST exception

static void call_tux(FBFR32*& tuxbuf, const char* service)
{
    long size = Fsizeof32(tuxbuf);

    // Call TUXEDO service
    if (tpcall((char*)service, (char*)tuxbuf, 0,
               (char**)&tuxbuf, &size, 0) == -1) {
        LOG("cannot access " << service);
        throw CORBA::PERSIST_STORE();
    }
}

//--------------------------------------------------------------------
// macro to handle exceptions in servant idl method implementations

#define HANDLE_EX                                   \
    catch (CORBA::Exception& e) {                   \
        LOG("unexpected CORBA::Exception : " << e); \
        throw;                                      \
    }                                               \
    catch (...) {                                   \
        LOG("unexpected exception");                \
        throw CORBA::INTERNAL();                    \
    }

//====================================================================
// Teller_i method implementations
//====================================================================

//--------------------------------------------------------------------

Teller_i::Teller_i() :
    m_tuxbuf((FBFR32*)tpalloc("FML32", "", 1000))
{
    TRACE_METHOD("Teller_i::Teller_i");

    if (m_tuxbuf == 0) {
        LOG("tpalloc failed with tperrno = " << tperrno);
        throw CORBA::INTERNAL();
    }
}

//--------------------------------------------------------------------

Teller_i::~Teller_i ()
{
    TRACE_METHOD("Teller_i::~Teller_i");

    // never let exceptions leak out of destructors :
    try {
        tpfree((char*)m_tuxbuf);
    }
    catch (...) {
        LOG("unexpected exception");
    }
}

//--------------------------------------------------------------------

CORBA::Double
Teller_i::get_balance(
    BillingP::AccountNumber account
)
{
    TRACE_METHOD("Teller_i::get_balance");
    TRACE("account = " << account);

    try {
	long account_l = account;

        // Form FML buffer. Note here we need to pass a reference to
        // a long (64-bit in case of OSF1) and not a CORBA_long
        Fchg32(m_tuxbuf, ACCOUNT_NO, 0, (char*)&account_l, 0);

        call_tux(m_tuxbuf, "CURRBALANCE");

        // Extract balance from FML buffer
        CORBA::Double currbal;
        Fget32(m_tuxbuf, CURR_BALANCE, 0, (char*)&currbal, 0);

        TRACE("balance = " << currbal);
        return currbal;
    }
    // We need to pass exceptions by reference in the catch clause
    catch (CORBA::PERSIST_STORE&) {
        throw; // pass thru
    }
    HANDLE_EX
}

//--------------------------------------------------------------------

void
Teller_i::credit(
    BillingP::AccountNumber account,
    CORBA::Double           amount
)
{
    TRACE_METHOD("Teller_i::credit");
    TRACE("account = " << account);
    TRACE("amount = " << amount);

    try {
	long account_l = account;

        // Form FML buffer
        Fchg32(m_tuxbuf, ACCOUNT_NO, 0, (char*)&account_l, 0);
        CORBA::Double amt = amount;
        Fchg32(m_tuxbuf, AMOUNT, 0, (char*)&amt, 0);

        // Call TUXEDO service
        call_tux(m_tuxbuf, "CREDIT");
    }
    catch (CORBA::PERSIST_STORE&) {
        throw; // pass thru
    }
    HANDLE_EX
}

//--------------------------------------------------------------------

void
Teller_i::debit(
    BillingP::AccountNumber account,
    CORBA::Double           amount
)
{
    TRACE_METHOD("Teller_i::debit");
    TRACE("account = " << account);
    TRACE("amount = " << amount);

    try {
	long account_l = account;

        // Form FML buffer
        Fchg32(m_tuxbuf, ACCOUNT_NO, 0, (char*)&account_l, 0);
        CORBA::Double amt = amount;
        Fchg32(m_tuxbuf, AMOUNT, 0, (char*)&amt, 0);

        call_tux(m_tuxbuf, "DEBIT");
    }
    catch (CORBA::PERSIST_STORE&) {
        throw; // pass thru
    }
    HANDLE_EX
}

//====================================================================
// TellerFactory_i method implementations
//====================================================================

//--------------------------------------------------------------------

TellerFactory_i::TellerFactory_i()
{
    TRACE_METHOD("TellerFactory_i::TellerFactory_i");
}

//--------------------------------------------------------------------

TellerFactory_i::~TellerFactory_i()
{
    TRACE_METHOD("TellerFactory_i::~TellerFactory_i");
}

//--------------------------------------------------------------------

BillingP::Teller_ptr
TellerFactory_i::find_teller(
    BillingP::AccountNumber account
)
{
    TRACE_METHOD("TellerFactory_i::find_teller");
    TRACE("account = " << account);

    try {

        // get the repository id for the teller's
        // IDL interface
        const char* teller_repos_id =
            BillingP::_tc_Teller->id();

        // use a unique id for the object_id to allow many
        // tellers to co-exist (for scaling)
        ostrstream os;
        UniqueId uid = UniqueId::generate();
        os << uid << ends;
        const char* object_id = os.str();
        os.rdbuf()->freeze(0);

        // create an object reference for the teller
        // and return it.

        // since the teller factory might be asked to
        // create teller references for accounts which are not
        // part of the teller factory's group, specify the
        // account in the criteria parameter. (that is,
        // use factory based routing)
        CORBA::NVList_var v_criteria;
        TP::orb()->create_list(1, v_criteria.out());
        CORBA::Any any;
        any <<= (CORBA::Long)account;
        v_criteria->add_value("account_number", any, 0);

        CORBA::Object_var v_reg_oref =
            TP::create_object_reference(
                teller_repos_id,
                object_id,
                v_criteria.in()
            );

        return BillingP::Teller::_narrow(v_reg_oref.in());
    }
    HANDLE_EX
}

//--------------------------------------------------------------------
