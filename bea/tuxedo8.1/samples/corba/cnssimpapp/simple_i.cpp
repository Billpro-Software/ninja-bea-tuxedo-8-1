//--------------------------------------------------------------------
//	(c) 2003 BEA Systems, Inc. All Rights Reserved.
//
// simple_i.cpp
//
// C++ servant implementations for the simple sample declaration.
//
// This file was originally generated by using the "-i" idl switch,
// then edited by hand.
//
// BEA Systems Inc. sample code
//
//--------------------------------------------------------------------

#include <wchar.h> // towupper, towlower
#include <TP.h>
#include "simple_i.h"

//--------------------------------------------------------------------
// Implementation of the Simple_i::to_lower method which converts
// a string to lower case.
//--------------------------------------------------------------------

wchar_t* Simple_i::to_lower(const wchar_t* val)
{
    // Make a copy of the incoming value.  Assign it to a var
    // so that if an exception occurs, then the new value will
    // automatically be deallocated since the ORB won't do it.
    CORBA::WString_var v_lower = CORBA::wstring_dup(val);

    wchar_t* p = v_lower;

    // Convert the string to lower case.
    for (long idx = 0; idx < wcslen(val); idx++) {
        p[idx] = towlower(val[idx]);
    }
  
    // Now that we know that the operation has succeeded, make
    // the var give up release responsibility for the string
    // we want to return since the ORB will take over release
    // responsibility for it.  
    return v_lower._retn();
}

//--------------------------------------------------------------------
// Implementation of the Simple_i::to_upper method which converts
// a string to upper case.
//--------------------------------------------------------------------

void Simple_i::to_upper(wchar_t*& val)
{
    // We could just scribble on the string that came in since
    // we're just converting it to upper case (that is, the size
    // of the "in" string is the same as the size of the "out"
    // string).  However, the more normal case is that the "out"
    // part of the inout string isn't the same size as the "in"
    // part of the inout string.  When this happens, the "in" one
    // has to be released and the "out" one has to be allocated.
    // Therefore, instead of just scribbling on the string, this
    // example show how to release the "in" one and allocate the
    // "out" one using vars.

    // Assign the "in" value to a var so that the var will release
    // it if we allocate a new string for the "out" value.
    CORBA::WString_var v_upper = CORBA::wstring_dup(val);

    // "CORBA::wstring_dup" allocated the "out" value (which
    // is a copy of the "in" value).  Assigning it to "v_upper"
    // causes the "in" value to be released.
    v_upper = CORBA::wstring_dup(v_upper.in());
    wchar_t* p = v_upper;

    // Convert the string to upper case.
    for (long idx=0; idx < wcslen(v_upper.in()); idx++) {
        p[idx] = towupper(p[idx]);
    }

    // Make "v_upper" give up release responsibility for its
    // string since the ORB needs to be responsible for releasing
    // the "out" value.
    val = v_upper._retn();
}

//--------------------------------------------------------------------
// Implementation of the SimpleFactory_i::find_simple method which
// creates an object reference to a Simple object.
//--------------------------------------------------------------------

Simple_ptr SimpleFactory_i::find_simple()
{
    // Use a var to hold the object reference so that it's
    // automatically released.

    // Instead of a non-unique id eg. "simple", use a unique id for the
    // object_id to allow many simple objects to co-exist. This will help
    // to avoid contention when running a lot of clients.

    // To make simpapp scalable, specify the parameter passed by the client
    // as the criteria while creating the Simple object reference.

    CORBA::String_var oid = generate_unique_id();

    CORBA::Object_var v_simple_oref =
        TP::create_object_reference(
            _tc_Simple->id(),     // interface id
            oid.in(),             // object id
            CORBA::NVList::_nil() // routing criteria
        );

    // Send back the narrowed reference.  The ORB will
    // be responsible for releasing it since it's a return value.
    return Simple::_narrow(v_simple_oref.in());
}

//--------------------------------------------------------------------
