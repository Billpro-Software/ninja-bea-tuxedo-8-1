//	(c) 2003 BEA Systems, Inc. All Rights Reserved. 
//--------------------------------------------------------------------
//
// simple_i.cpp
//
// C++ servant implementations for the simpapp_par sample declaration.
//
// This file was originally generated by using the "-i" idl switch,
// then edited by hand.
//
// BEA Systems Inc. sample code
//
//--------------------------------------------------------------------

#include <ctype.h> // toupper, tolower
#include <TP.h>
#include <stdio.h>
#include "simple_i.h"

#ifdef WIN32
#include <process.h>
#include <windows.h>
#else
#include <unistd.h>
#endif

#ifdef WIN32
#define TEST_SLEEP(NumSec) \
            Sleep(NumSec * 1000);
#else
#define TEST_SLEEP(NumSec) \
    { unsigned int sleft, ii;\
      for (ii = 0, sleft = NumSec; ii < NumSec; ii++) {\
        sleft = sleep(sleft);\
        if (sleft == 0)\
            break;\
      } }
#endif

//--------------------------------------------------------------------
// Implementation of the Simple_i::to_lower method which converts
// a string to lower case.
//--------------------------------------------------------------------

char* Simple_i::to_lower(const char* val)
{
    // Make a copy of the incoming value.  Assign it to a var
    // so that if an exception occurs, then the new value will
    // automatically be deallocated since the ORB won't do it.
    CORBA::String_var v_lower = CORBA::string_dup(val);

    // Convert the string to lower case.
    for (char* p = v_lower; p && *p; p++) {
        *p = tolower(*p);
    }

    // Now that we know that the operation has succeeded, make
    // the var give up release responsibility for the string
    // we want to return since the ORB will take over release
    // responsibility for it.  
    return v_lower._retn();
}

//--------------------------------------------------------------------
// Implementation of the Simple_i::to_upper method which converts
// a string to upper case.
//--------------------------------------------------------------------

void Simple_i::to_upper(char*& val)
{
    // We could just scribble on the string that came in since
    // we're just converting it to upper case (that is, the size
    // of the "in" string is the same as the size of the "out"
    // string).  However, the more normal case is that the "out"
    // part of the inout string isn't the same size as the "in"
    // part of the inout string.  When this happens, the "in" one
    // has to be released and the "out" one has to be allocated.
    // Therefore, instead of just scribbling on the string, this
    // example show how to release the "in" one and allocate the
    // "out" one using vars.

    // Assign the "in" value to a var to that the var will release
    // it if we allocate a new string for the "out" value.
    CORBA::String_var v_upper = val;

    // "CORBA::string_dup" allocated the "out" value (which
    // is a copy of the "in" value).  Assigning it to "v_upper"
    // causes the "in" value to be released.
    v_upper = CORBA::string_dup(v_upper.in());

    // Convert the string to upper case.
    for (char* p = v_upper; p && *p; p++) {
        *p = toupper(*p);
    }

    // Make "v_upper" give up release responsibility for its
    // string since the ORB needs to be responsible for releasing
    // the "out" value.
    val = v_upper._retn();
}

//--------------------------------------------------------------------
// Implementation of the Simple_i::s_pid method which returns 
// the process id of the server used to handle the request.
//--------------------------------------------------------------------

CORBA::Long Simple_i::s_pid()
{
    // Pause for 3 seconds to make it easier to see what 
    // happens when multiple clients are active at the same 
    // time
    TEST_SLEEP(3)
    return getpid();
}

//--------------------------------------------------------------------
