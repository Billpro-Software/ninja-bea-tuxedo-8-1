//--------------------------------------------------------------------
//	(c) 2003 BEA Systems, Inc. All Rights Reserved.
//
// personqueryc.cpp
//
// C++ client program for the interceptor samples 
//
// BEA Systems Inc. sample code
//
//--------------------------------------------------------------------
//
// This file contains the C++ PersonQuery client application.  It is
// intended to be used to demonstrate the functionality of Tuxedo
// Request Level Interceptors.
//
// The application accepts command line input which it translates into
// database queries.  The queries are made as CORBA requests to the
// PersonQuery server (either C++ or Java) which return entries that
// satisfy the search criteria.
//
// Most of the code in the client implements the command line parsing
// and construction of parameters for invocations to the PersonQuery
// server.
//
// A typical session would consist of a user entering search criteria
// on the command line, for example:
//
// Options?
//	age 16 hair blue         [entered by user]
//      hits: 3                  [returned to client by server; number of
//                                database entries that satisfy the
//                                entered criteria]
//
// This line is parsed for keywords (age, hair) and accompanying values
// (16, blue).  The keywords allow the parser to understand the intention
// of the data - for example, "blue" is a valid value for hair and eyes.
//
// Once identified, the values are loaded into an appropriate data type
// and included in a CORBA request to the server.  The requests are
// made by client stubs generated by the Tuxedo C++ idl compiler.
//
// There are multiple operations in the PersonQuery interface, depending
// upon the search criteria entered on the command line.  Some functionality
// in the client is dedicated to determining the best operation to invoke
// upon, and constructing the appropriate request parameters.
//
// In order to see the actual results returned from the request, the user
// must enter the command "result".  The "result" command causes the client
// to output the request results to standard out.
//
// Only the last search is output, so the user can narrow or widen the
// search, depending upon the number of entries found.
//
// To end the session, enter "exit". This command causes the client to
// free resources and exit.
//


#include <ctype.h>
#include <stdlib.h>
#ifdef WIN32
#include <strstrea.h>
#else
#include <strstream.h>
#endif
#include <Tobj_Bootstrap.h>
#include <tobj_c.h>
#include "personquery_c.h"
#include "ex.h"

#ifndef FALSE
#define FALSE 0
#endif
#ifndef TRUE
#define TRUE 1
#endif

#if defined(__SUNPRO_CC_COMPAT) && __SUNPRO_CC_COMPAT >= 5
#define WS std::ws
#else
#define WS ws
#endif


//--------------------------------------------------------------------
// Macro to report any exceptions that occur
//
// catch all exceptions, report the exception to standard error,
// then continue (v.s. rethrow)
//--------------------------------------------------------------------
#define CATCH_REPORT_AND_SWALLOW_EXCEPTION                       \
                                                                 \
  catch (CORBA::SystemException& e) {                            \
    cerr << "unexpected CORBA::SystemException : " << e << endl; \
  }                                                              \
  catch (CORBA::Exception& e) {                                  \
    cerr << "unexpected CORBA::Exception : " << e << endl;       \
  }                                                              \
  catch (...) {                                                  \
    cerr << "unexpected exception" << endl;                      \
  }


//--------------------------------------------------------------------
// Utility functions to display the query results to standard out
//--------------------------------------------------------------------
//
// These functions translate the returned PersonQuery::Person list to
// more user-friend values that the structure contains, and output to 
// standard out. 
//
static void displayHobby(PersonQuery::HOBBIES rec)
{
      switch (rec)
      {
         default:
           {
           PersonQuery::Reason r;
           r.rec(rec);
           throw PersonQuery::DataOutOfRange(r);
           }
         case PersonQuery::who_cares:
           cout << "who cares?" << endl;
           break;
         case PersonQuery::rocks:
           cout << "rock climbing" << endl;
           break;
         case PersonQuery::swim:
           cout << "swimming" << endl;
           break;
         case PersonQuery::tv:
           cout << "watching tv" << endl;
           break;
         case PersonQuery::stamps:
           cout << "collecting stamps" << endl;
           break;
         case PersonQuery::photo:
           cout << "photography" << endl;
           break;
         case PersonQuery::weaving:
           cout << "weaving" << endl;
           break;
      }
}
static void displayMarriage(PersonQuery::MARRIAGE mar)
{
      switch (mar)
      {
         default:
           {
           PersonQuery::Reason r;
           r.mar(mar);
           throw PersonQuery::DataOutOfRange(r);
           }
         case PersonQuery::not_known:
           cout << "not known" << endl;
           break;
         case PersonQuery::single:
           cout << "single" << endl;
           break;
         case PersonQuery::married:
           cout << "married" << endl;
           break;
         case PersonQuery::divorced:
           cout << "divorced" << endl;
           break;
      }
}
static void displaySex(PersonQuery::SEX sex)
{
      switch (sex)
      {
         default:
           {
           PersonQuery::Reason r;
           r.sex(sex);
           throw PersonQuery::DataOutOfRange(r);
           }
         case PersonQuery::cant_tell:
           cout << "cant tell" << endl;
           break;
         case PersonQuery::male:
           cout << "male" << endl;
           break;
         case PersonQuery::female:
           cout << "female" << endl;
           break;
      }
}
static void displayOther(PersonQuery::MARKINGS other)
{
      switch (other)
      {
         default:
           {
           PersonQuery::Reason r;
           r.other(other);
           throw PersonQuery::DataOutOfRange(r);
           }
         case PersonQuery::dont_care:
           cout << "dont_care" << endl;
           break;
         case PersonQuery::tattoo:
           cout << "tattoo" << endl;
           break;
         case PersonQuery::missing_limb:
           cout << "missing_limb" << endl;
           break;
         case PersonQuery::scar:
           cout << "scar" << endl;
           break;
         case PersonQuery::none:
           cout << "none" << endl;
           break;
      }
}
//
// While the PersonQuery interface has a single enum type which defines
// all the colors used in the database, the physical feature may not
// allow all the colors.  For example, skin is rarely blue.

void displayColor(PersonQuery::COLOR col, CORBA::Short kind)
{
      switch (col)
      {
         default:
           {
             // don't know this color, not defined in the application
             // idl.  Construct a Reason to send with the exception.
             PersonQuery::Reason r;
             switch (kind)
             {
              case 10:
                 r.hair(col);
                 break;
              case 11:
                 r.eyes(col);
                 break;
              case 12:
                 r.skin(col);
                 break;
              default:
                 r.name("");
                 break;
             }
             throw PersonQuery::DataOutOfRange(r);
           }

         // These are all the colors we know.  Output them to stdout.
         case PersonQuery::white:
           cout << "white" << endl;
           break;
         case PersonQuery::black:
           cout << "black" << endl;
           break;
         case PersonQuery::red:
           cout << "red" << endl;
           break;
         case PersonQuery::brown:
           cout << "brown" << endl;
           break;
         case PersonQuery::green:
           cout << "green" << endl;
           break;
         case PersonQuery::violet:
           cout << "violet" << endl;
           break;
         case PersonQuery::blue:
           cout << "blue" << endl;
           break;
         case PersonQuery::gray:
           cout << "gray" << endl;
           break;
         case PersonQuery::unknown:
           cout << "unknown" << endl;
           break;
         case PersonQuery::yellow:
           cout << "yellow" << endl;
           break;
         case PersonQuery::hazel:
           cout << "hazel" << endl;
           break;
         case PersonQuery::dontcare:
           cout << "dontcare" << endl;
           break;
      }
}

//
// Display an entire Person structure. Could also be used for
// debugging.
//
static void displayPerson(PersonQuery::Person p)
{
      cout << "         name: " << p.name.in() << endl;
      cout << "      address: " << p.addr.number 
                                << " " << p.addr.street.in() << endl;
      cout << "               " << p.addr.town.in() << ","
                                << p.addr.state.in() << " "
                                << p.addr.country.in() << endl;
      cout << "           ss: " << p.ss.in() << endl;
      cout << "          sex: ";
      displaySex(p.sex);
      cout << "          age: " << p.age << endl;
      cout << "     marriage: ";
      displayMarriage(p.mar);
      cout << "        hobby: ";
      displayHobby(p.rec);
      cout << "          dob: " << p.dob.month << "/"
                                << p.dob.day << "/"
                                << p.dob.year << endl;
      cout << "       height: " << p.ht << " inches" << endl;
      cout << "       weight: " << p.wt << " pounds" << endl;
      cout << "         hair: ";
      displayColor(p.hair, 10);
      cout << "         eyes: ";
      displayColor(p.eyes, 11);
      cout << "         skin: ";
      displayColor(p.skin, 12);
      cout << "        other: ";
      displayOther(p.other);
      cout << endl << endl;
}

//
// Display all the entries returned from the query. This
// is called when the user enters the "result" command, but
// it could also be used for debugging.
//
static void displayHits(PersonQuery::Possibles *hits)   
{
    //
    // if there are no entries, just return
    //

    if (!hits)
       return;
    if (hits->length() == 0)
       return;

    //
    // Walk thru the sequence and display the values.
    //
    PersonQuery::Person *p = hits->OBB__GetData();
    for (CORBA::ULong i = 0; i < hits->length(); i++, p++)
    {
       displayPerson(*p);
    }
    return;

}


//--------------------------------------------------------------------
// Local class to handle user interface
//--------------------------------------------------------------------
// This class defines the functionality which handles command line
// parsing and processing.
//
// The command line is parsed by obtaining a token, and determining
// which keyword it is.  Then, keyword-specific functions are called
// to parse the value which follows.
//
// Multiple keyword/values can be entered on a single command line, so
// the parser continues processing until if reaches the EOL.  A single
// command line defines a single query request, however.
//
class input_data
{
public:
	input_data();
	virtual ~input_data() {}

	// The possible keywords
	enum KeyWord {
                  name    = 1,
                  address = 2,
                  ss      = 4,
                  sex     = 8,
                  age     = 16,
                  mar     = 32,
                  rec     = 64,
                  dob     = 128,
                  ht      = 256,
                  wt      = 512,
                  hair    = 1024,
                  skin    = 2048,
                  eyes    = 4096,
                  other   = 8192,
                  result  = 16384,
                  exit    = 32768 };

        // the controlling function, get_input will call other
        // input_data function members to parse substrings of the
        // command line. 'get_keyword' is responsible for getting
        // and identifying the next keyword on the command line.
        void			get_input();
	int			get_keyword(KeyWord &key);
	void 			get_name();
	void			get_address();
	void 			get_ss();
	void 			get_sex();
	void			get_age();
	void			get_marriage();
	void			get_hobby();
	void			get_dob();
	void			get_ht();
	void			get_wt();
	void			get_hair();
	void			get_eyes();
	void			get_skin();
	void			get_other();
        void                    get_result();
        void                    get_exit();

        // this function displays the command line options to the user.
	void display_options();

        // accessors for the fields bits.  The fields bits keep track
        // of what data the user has entered, so we can tell what kind
        // of request to make.
        short			get_fields_set() { return m_fields_set; }
        short			fields() { return m_fields; }

        // the query data.  These fields hold the values entered on the
        // command line.  They are used to construct the appropriate
        // requests.
        char                   m_the_name[100];
        PersonQuery::Address   m_the_address;
        char                   m_the_ss[12];
        PersonQuery::SEX       m_the_sex;
        short                  m_the_age;
        PersonQuery::MARRIAGE  m_the_mar;
        PersonQuery::HOBBIES   m_the_rec;
        PersonQuery::Date      m_the_dob;
        short                  m_the_ht;
        long                   m_the_wt;
        PersonQuery::COLOR     m_the_hair;
        PersonQuery::COLOR     m_the_eyes;
        PersonQuery::COLOR     m_the_skin;
        PersonQuery::MARKINGS  m_the_other;

private:
        // this function converts all command line input to upper case.
	void convert(char *the_data);

        // these members define the actual keyword strings
	const char *m_name;
	const char *m_address;
	const char *m_ss;
	const char *m_sex;
	const char *m_age;
	const char *m_mar;
	const char *m_rec;
	const char *m_dob;
	const char *m_ht;
	const char *m_wt;
	const char *m_hair;
	const char *m_skin;
	const char *m_eyes;
	const char *m_other;
	const char *m_result;
	const char *m_exit;

        // these members are data used for parsing.
	int	   m_done;		// we've reached the end of line
	short      m_fields;		// the data that's been gathered
        short      m_fields_set;	// keeps track of whats been gathered.
        istrstream *m_in_data;		// the object which gets keyboard
                                        // input from the user. the input_data
                                        // class uses this to parse the
                                        // input string.
};


//--------------------------------------------------------------------
// utility to parse tokens entered by the user.
//--------------------------------------------------------------------
input_data::input_data()
{
    m_done = FALSE;

    // initialize the keyword strings, always in upper case.
    m_name    = "NAME";
    m_address = "ADDRESS";
    m_ss      = "SS";
    m_sex     = "SEX";
    m_age     = "AGE";
    m_mar     = "MARRIAGE";
    m_rec     = "HOBBY";
    m_dob     = "DOB";
    m_ht      = "HT";
    m_wt      = "WT";
    m_hair    = "HAIR";
    m_skin    = "SKIN";
    m_eyes    = "EYES";
    m_other   = "OTHER";
    m_result  = "RESULT";
    m_exit    = "EXIT";

    // no search criteria entered yet.
    m_fields = 0;
    m_fields_set = 0;
 
    // no input object yet.
    m_in_data   = NULL;

    // no search criteria entered yet.  Initialize all fields
    // to their "don't care" values.
    m_the_sex   = PersonQuery::cant_tell;
    m_the_age   = 0;
    m_the_mar   = PersonQuery::not_known;
    m_the_rec   = PersonQuery::who_cares;
    m_the_wt    = 0;
    m_the_ht    = 0;
    m_the_hair  = PersonQuery::dontcare;
    m_the_eyes  = PersonQuery::dontcare;
    m_the_skin  = PersonQuery::dontcare;
    m_the_other = PersonQuery::dont_care;
    
}

//
// function to convert the input string to upper case
//
void input_data::convert(char *the_data)
{
    long    i;

    i = 0;
    while (the_data[i] != 0)
    {
       the_data[i] = toupper(the_data[i]);
       i++;
    }
}

//
// 'get_input' is the main input processing function.
//
// It outputs the Options? string to the screen, and gets input
// from the user.  It then parses the input and initializes the
// appropriate data members.  It updates the bit fields to specify
// which data members contain non-default values.
//
void input_data::get_input()
{
    input_data::KeyWord key;
    char  the_data[256];      // the buffer which will contain user input.

    /*
     *  get the entire input line and create a string stream from it.
     *  We'll parse the string stream to get each part of the query, the
     *  set the bit fields as to what data was entered.
     */

    cout                                       << endl;
    cout << "--------------------------------" << endl;
    cout << "Option? " << flush;

    // get input from the user
    cin.getline(the_data, 256);


    m_done = FALSE;
    m_fields = 0;
    m_fields_set = 0;
    convert(the_data);

    // create the istrstream. This is new with every command line entered.

    m_in_data = new istrstream(the_data);
    if (!m_in_data)
      throw CORBA::NO_MEMORY();

    /* 
     * parse the input stream, setting the field bit and data for each
     * data item entered. Depending upon the keyword, call specific functions
     * to parse the value.
     */

    while (get_keyword(key))
    {
        switch (key) {

          case input_data::name:
            get_name(); 
            break;

          case input_data::address:
            get_address(); 
            break;

          case input_data::ss:
            get_ss(); 
            break;

          case input_data::sex:
            get_sex(); 
            break;

          case input_data::age:
	    get_age();
            break;

          case input_data::mar:
	    get_marriage();
            break;

          case input_data::rec:
	    get_hobby();
            break;

          case input_data::dob:
	    get_dob();
            break;

          case input_data::ht:
	    get_ht();
            break;

          case input_data::wt:
	    get_wt();
            break;

          case input_data::hair:
	    get_hair();
            break;

          case input_data::skin:
	    get_skin();
            break;

          case input_data::eyes:
	    get_eyes();
            break;

          case input_data::other:
	    get_other();
            break;

          case input_data::result:
            get_result();
            break;

          case input_data::exit:
            get_exit();
            break;

          default :
            display_options();
            break;
        }
    }

    // have finished this command line. Return for the actual query,
    // based on the data parsed out here.
    delete m_in_data;
    return;
}

//
// Parse out the keyword and return which one it was.
// This function returns TRUE if a keyword was found,
// or if a token was lexed out of the 
// input stream.
//
int input_data::get_keyword(input_data::KeyWord &key)
{
    char keyword[256];
    int ret_val = FALSE;

    keyword[0] = 0;

    // remove white space as we extract the keyword string.
    *m_in_data >> WS >> keyword;
    if (strlen(keyword) > 0)
    {
        if (strcmp(keyword, m_name) == 0)
          key = input_data::name; 
        else if (strcmp(keyword, m_address) == 0)
          key = input_data::address; 
        else if (strcmp(keyword, m_ss) == 0)
          key = input_data::ss; 
        else if (strcmp(keyword, m_sex) == 0)
          key = input_data::sex; 
        else if (strcmp(keyword, m_age) == 0)
          key = input_data::age; 
        else if (strcmp(keyword, m_mar) == 0)
          key = input_data::mar; 
        else if (strcmp(keyword, m_rec) == 0)
          key = input_data::rec; 
        else if (strcmp(keyword, m_dob) == 0)
          key = input_data::dob; 
        else if (strcmp(keyword, m_ht) == 0)
          key = input_data::ht; 
        else if (strcmp(keyword, m_wt) == 0)
          key = input_data::wt; 
        else if (strcmp(keyword, m_hair) == 0)
          key = input_data::hair; 
        else if (strcmp(keyword, m_skin) == 0)
          key = input_data::skin; 
        else if (strcmp(keyword, m_eyes) == 0)
          key = input_data::eyes; 
        else if (strcmp(keyword, m_other) == 0)
          key = input_data::other; 
        else if (strcmp(keyword, m_result) == 0)
          key = input_data::result; 
        else if (strcmp(keyword, m_exit) == 0)
          key = input_data::exit; 
        ret_val = TRUE;
    }

    return ret_val;
}


//------------------------------------------------------------------
// Get the query name 
//
// If the name has multiple tokens, it must be surrounded by double
// quotes. A name can contain white space if surrounded by quotes.
//
//------------------------------------------------------------------
void input_data::get_name()
{

   char tmp[100];              // this is the buffer we analyze.
   char *end_quote = NULL;

   // extract the token.
   *m_in_data >> tmp;

   // assume there is no name.
   m_the_name[0] = 0;

   // the name is double quoted.  Read until the ending double quote.
   if (tmp[0] == '"')
   {
      // find the ending double quote, temporarily make it a NULL terminator
      // then copy the string to the name data member.
      end_quote = strchr(&tmp[1], '"');
      if (end_quote)
        *end_quote = 0;
      strcat(m_the_name, &tmp[1]);
      while (!end_quote)
      {
         *m_in_data >> tmp;
         end_quote = strchr(tmp, '"');
         if (end_quote)
           *end_quote = 0;
         strcat(m_the_name, " ");
         strcat(m_the_name, tmp);
      }
   }
   else strcat(m_the_name, tmp);

   // if we actually had a name string, set the bit field.
   // if not, there must have been an EOL before the name was found,
   // the command line is done.

   if (strlen(m_the_name) > 0)
   {
      m_fields |= input_data::name;
      m_fields_set++;
   }
   else m_done = TRUE;
   return;
}


//------------------------------------------------------------------
// Get the query address 
//
// The address consists of number, street, town, state, and country.
// The street, town, state, and country must be separated by commas. 
// The entire address must be surrounded by double quotes.
//------------------------------------------------------------------
void input_data::get_address()
{

   char tmp[100];
   char tmp2[200];
   char *end_quote = NULL;
   int addr_done = FALSE;
   int done = FALSE;

   m_the_address.number = 0;
   m_the_address.street = (char *)NULL;
   m_the_address.town = (char *)NULL;
   m_the_address.state = (char *)NULL;
   m_the_address.country = (char *)NULL;

   // get the first token, up to the first white space.
   *m_in_data >> tmp;

   // must have a double quote.
   if (tmp[0] == '"')
   {

      // always check for that ending double quote, which
      // means this is the last token.
      end_quote = strchr(&tmp[1], '"');
      if (end_quote != NULL)
         addr_done = TRUE;

      // get the street number.
      m_the_address.number = atoi(&tmp[1]);

      // Get the street name
      if (!addr_done)
      {
         // the next tokens should be the street.
         // the street can be multiple token, like "Penny Lane",
         // so check for the street terminator, a comma.
         *m_in_data >> tmp;
         tmp2[0] = 0;
         done = FALSE;
         while (!done)
         {
            // find the comma and figure out if the address is done.
            char *end_street = strchr(tmp, ',');
            end_quote = strchr(tmp, '"');
            if (end_street || end_quote)
              done = TRUE;
            if (end_street)
              *end_street = 0;
            if (end_quote)
              *end_quote = 0;

            // copy the street and get the next street token.
            strcat(tmp2, tmp);
            if (!done)
            {
               strcat(tmp2, " ");
               *m_in_data >> tmp;
            }
         }
         // have the whole street, store it.
         m_the_address.street = CORBA::string_dup(tmp2);
         if (end_quote)
            addr_done = TRUE;
      }
           
      // Get the town
      if (!addr_done)
      {
         // the town can be multiple tokens, like "New Boston".
         // Look for the terminating comma.

         // get the first town token
         *m_in_data >> tmp;

         tmp2[0] = 0;
         done = FALSE;
         while (!done)
         {
            // look for the comma and figure out if it's the
            // end of the command.
            char *end_town = strchr(tmp, ',');
            end_quote = strchr(tmp, '"');
            if (end_town || end_quote)
              done = TRUE;
            if (end_town)
              *end_town = 0;
            if (end_quote)
              *end_quote = 0;

            // store this town token and get the next one.
            strcat(tmp2, tmp);
            if (!done)
            {
               strcat(tmp2, " ");
               *m_in_data >> tmp;
            }
         }
         // have the town, store it.
         m_the_address.town = CORBA::string_dup(tmp2);
         if (end_quote)
            addr_done = TRUE;
      }

      // Get the state
      if (!addr_done)
      {
         // Allow multiple tokens for the state.  State is a USA term,
         // but this should handle any kind of political boundary that
         // would come after a street.

         // Get the first state token.
         *m_in_data >> tmp;
         tmp2[0] = 0;
         done = FALSE;
         while (!done)
         {
            // look for the terminating comma and figure out if this
            // is the last token of the state or the command.
            char *end_state = strchr(tmp, ',');
            end_quote = strchr(tmp, '"');
            if (end_state || end_quote)
              done = TRUE;
            if (end_state)
              *end_state = 0;
            if (end_quote)
              *end_quote = 0;

            // store this token and get the next one.
            strcat(tmp2, tmp);
            if (!done)
            {
               strcat(tmp2, " ");
               *m_in_data >> tmp;
            }
         }
         // store the state in the data member.
         m_the_address.state = CORBA::string_dup(tmp2);
         if (end_quote)
            addr_done = TRUE;
      }

      // Get the country
      if (!addr_done)
      {
         // Countries can also be multiple tokens.  This is the
         // last part of an address, so look for a double quote,
         // a comma, or an end of line.

         // Get the first country token.
         *m_in_data >> tmp;
         tmp2[0] = 0;
         done = FALSE;
         while (!done)
         {
            // Look for the quote or comma. Figure out if we're done.
            char *end_country = strchr(tmp, ',');
            end_quote = strchr(tmp, '"');
            if (end_country || end_quote)
              done = TRUE;
            if (end_country)
              *end_country = 0;
            if (end_quote)
              *end_quote = 0;

            // Store this country token and get the next one.
            strcat(tmp2, tmp);
            if (!done)
            {
               strcat(tmp2, " ");
               *m_in_data >> tmp;
            }
         }
         // We've got the country, store it in the data member.
         m_the_address.country = CORBA::string_dup(tmp2);
      }

      // If we got here, we've successfully parsed out a legal address,
      // so set the address bit field.
      m_fields |= input_data::address;
      m_fields_set++;
   }

   // no double quote, we're done by definition.
   else m_done = TRUE;
 
   return;
}

//------------------------------------------------------------------
// Get the query ss # 
//
// The ss is entered as:  xxx-xx-xxxx.  However don't put any
// constraints on that.  Just read it as a string.
//------------------------------------------------------------------
void input_data::get_ss()
{
   char tmp[100];

   // get the SS token.  If there was something there, assume it's
   // ok.  Store it and set the ss bit field.
   *m_in_data >> tmp;
   if (strlen(tmp) > 0)
   {
      strcpy(m_the_ss, tmp);
      m_fields |= input_data::ss;
      m_fields_set++;
   }
   // no string there, command is done.
   else m_done = TRUE;
   return;
}

//------------------------------------------------------------------
// Get the query age 
//
// Age is an integer, so extract it from the input stream with a
// typed operator.  An age of zero means an end of the command.
//------------------------------------------------------------------
void input_data::get_age()
{
   *m_in_data >> m_the_age;

   if (m_the_age > 0)
   {
      m_fields |= input_data::age;
      m_fields_set++;
   }
   else m_done = TRUE;
   return;
}

//------------------------------------------------------------------
// Get the query sex 
//
// The sex is specified as a string.  Get the string and convert it
// to the PersonQuery::SEX enum value. 
//------------------------------------------------------------------
void input_data::get_sex()
{
   char tmp[100];

   // get the token as a string.
   *m_in_data >> tmp;

   // we have one.  Translate to an enum value.
   if (strlen(tmp) > 0)
   {
      if (strcmp(tmp, "MALE") == 0)
        m_the_sex = PersonQuery::male;
      else if (strcmp(tmp, "FEMALE") == 0)
        m_the_sex = PersonQuery::female;
      else if (strcmp(tmp, "CANT_TELL") == 0)
        m_the_sex = PersonQuery::cant_tell;
      else m_the_sex = PersonQuery::cant_tell;
      m_fields |= input_data::sex;
      m_fields_set++;
   }
   else m_done = TRUE;
   return;
}

//------------------------------------------------------------------
// Get the query marriage status 
//
// Marital status is entered as a string, but translated to the
// PersonQuery::MARRIAGE enum.
//------------------------------------------------------------------
void input_data::get_marriage()
{
   char tmp[100];

   // Get the marriage token
   *m_in_data >> tmp;

   // We got a token, translate to the enum value and set the bit field.
   if (strlen(tmp) > 0)
   {
      if (strcmp(tmp, "MARRIED") == 0)
        m_the_mar = PersonQuery::married;
      else if (strcmp(tmp, "SINGLE") == 0)
        m_the_mar = PersonQuery::single;
      else if (strcmp(tmp, "NOT_KNOWN") == 0)
        m_the_mar = PersonQuery::not_known;
      else if (strcmp(tmp, "DIVORCED") == 0)
        m_the_mar = PersonQuery::divorced;
      else m_the_mar = PersonQuery::not_known;
      m_fields |= input_data::mar;
      m_fields_set++;
   }
   else m_done = TRUE;
   return;
}

//------------------------------------------------------------------
// Get the query hobby 
//
// Hobbies are entered as strings and translated to the 
// PersonQuery::HOBBIES enum.
//------------------------------------------------------------------
void input_data::get_hobby()
{
   char tmp[100];

   // Get the hobby as a string.
   *m_in_data >> tmp;

   // We have a value.  Translate to the enum and set the bit field.
   if (strlen(tmp) > 0)
   {
      if (strcmp(tmp, "WHO_CARES") == 0)
        m_the_rec = PersonQuery::who_cares;
      else if (strcmp(tmp, "ROCKS") == 0)
        m_the_rec = PersonQuery::rocks;
      else if (strcmp(tmp, "SWIM") == 0)
        m_the_rec = PersonQuery::swim;
      else if (strcmp(tmp, "TV") == 0)
        m_the_rec = PersonQuery::tv;
      else if (strcmp(tmp, "STAMPS") == 0)
        m_the_rec = PersonQuery::stamps;
      else if (strcmp(tmp, "PHOTO") == 0)
        m_the_rec = PersonQuery::photo;
      else if (strcmp(tmp, "WEAVING") == 0)
        m_the_rec = PersonQuery::weaving;
      else m_the_rec = PersonQuery::who_cares;
      m_fields |= input_data::rec;
      m_fields_set++;
   }
   else m_done = TRUE;
   return;
}

//------------------------------------------------------------------
// Get the query date of birth 
//
// The date is a string entered as:  mm/dd/yyyy.  Quotes are not
// necessary, but the slashes are.
//------------------------------------------------------------------
void input_data::get_dob()
{
   char tmp[100];
   char *tmp2;

   // Get the date token.
   *m_in_data >> tmp;

   // We have a token
   if (strlen(tmp) > 0)
   {
      //  tmp holds the original token, tmp2 points into the token
      char *c = NULL;
      tmp2 = tmp;

      // find the first slash. Temporarily replace it with a NULL
      // terminator and translate the month field to the
      // PersonQuery::MONTHS enum values. 
      c = strchr(tmp2, '/');
      if (c)
      {
        *c = 0;
        if (strcmp(tmp, "1") == 0 || strcmp(tmp, "01") == 0)
           m_the_dob.month = PersonQuery::Jan;
        else if (strcmp(tmp, "2") == 0 || strcmp(tmp, "02") == 0)
           m_the_dob.month = PersonQuery::Feb;
        else if (strcmp(tmp, "3") == 0 || strcmp(tmp, "03") == 0)
           m_the_dob.month = PersonQuery::Mar;
        else if (strcmp(tmp, "4") == 0 || strcmp(tmp, "04") == 0)
           m_the_dob.month = PersonQuery::Apr;
        else if (strcmp(tmp, "5") == 0 || strcmp(tmp, "05") == 0)
           m_the_dob.month = PersonQuery::May;
        else if (strcmp(tmp, "6") == 0 || strcmp(tmp, "06") == 0)
           m_the_dob.month = PersonQuery::Jun;
        else if (strcmp(tmp, "7") == 0 || strcmp(tmp, "07") == 0)
           m_the_dob.month = PersonQuery::Jul;
        else if (strcmp(tmp, "8") == 0 || strcmp(tmp, "08") == 0)
           m_the_dob.month = PersonQuery::Aug;
        else if (strcmp(tmp, "9") == 0 || strcmp(tmp, "09") == 0)
           m_the_dob.month = PersonQuery::Sep;
        else if (strcmp(tmp, "10") == 0)
           m_the_dob.month = PersonQuery::Oct;
        else if (strcmp(tmp, "11") == 0)
           m_the_dob.month = PersonQuery::Nov;
        else if (strcmp(tmp, "12") == 0)
           m_the_dob.month = PersonQuery::Dec;

        // Put the slash back, move the tmp2 pointer past it and
        // find the next slash (the one between the day and year).
        // Put a temporary NULL into that slash and translate the
        // day to a numeric value.  At this point, we also know
        // where the year is in the string, so translate that
        // to a numeric value and set the date of birth bit field.
        *c = '/';
        tmp2 = ++c;
        c = strchr(tmp2, '/');
        if (c)
        {
           *c = 0;
           m_the_dob.day = (short) atoi(tmp2);
           *c = '/';
           tmp2 = ++c;
           m_the_dob.year = (short) atoi(tmp2);
           m_fields |= input_data::dob;
           m_fields_set++;
           return;
        }
      }
   }
   m_done = TRUE;
   return;
}

//------------------------------------------------------------------
// Get the query height 
//
// Height is entered as a string, but use an integer typed operator
// to translate it to an integer.  If there was a value there,
// set the bit field.
//------------------------------------------------------------------
void input_data::get_ht()
{
   *m_in_data >> m_the_ht;

   if (m_the_ht > 0)
   {
      m_fields |= input_data::ht;
      m_fields_set++;
   }
   else m_done = TRUE;
   return;
}


//------------------------------------------------------------------
// Get the query weight 
//
// Weight is entered as a string, but use an integer typed operator
// to translate it to an integer.  If there was a value there,
// set the bit field.
//------------------------------------------------------------------
void input_data::get_wt()
{
   *m_in_data >> m_the_wt;

   if (m_the_wt > 0)
   {
      m_fields |= input_data::wt;
      m_fields_set++;
   }
   else m_done = TRUE;
   return;
}


//------------------------------------------------------------------
// Get the query hair color 
//
// Colors are entered as string and translated to PersonQuery::COLOR
// enum values.  Only some of the enum values are legal for hair
// color, so only translate the ones allowed.
//------------------------------------------------------------------
void input_data::get_hair()
{
   char  tmp[100];

   // get the hair string token
   *m_in_data >> tmp;

   // if we have a string, translate to the enum value and set the bit field.
   if (strlen(tmp) > 0)
   {
      if (strcmp(tmp, "WHITE") == 0)
        m_the_hair = PersonQuery::white;
      else if (strcmp(tmp, "BLACK") == 0)
        m_the_hair = PersonQuery::black;
      else if (strcmp(tmp, "BROWN") == 0)
        m_the_hair = PersonQuery::brown;
      else if (strcmp(tmp, "YELLOW") == 0)
        m_the_hair = PersonQuery::yellow;
      else if (strcmp(tmp, "RED") == 0)
        m_the_hair = PersonQuery::red;
      else if (strcmp(tmp, "GREEN") == 0)
        m_the_hair = PersonQuery::green;
      else if (strcmp(tmp, "GRAY") == 0)
        m_the_hair = PersonQuery::gray;
      else if (strcmp(tmp, "BLUE") == 0)
        m_the_hair = PersonQuery::blue;
 
      m_fields |= input_data::hair;
      m_fields_set++;
   }
   else m_done = TRUE;
   return;
}

//------------------------------------------------------------------
// Get the query skin color 
//
// Colors are entered as string and translated to PersonQuery::COLOR
// enum values.  Only some of the enum values are legal for skin
// color, so only translate the ones allowed.
//------------------------------------------------------------------
void input_data::get_skin()
{
   char  tmp[100];

   // Get the skin color token.
   *m_in_data >> tmp;

   // We got a string, so translate it to the enum value and set the bit field.
   if (strlen(tmp) > 0)
   {
      if (strcmp(tmp, "WHITE") == 0)
        m_the_skin = PersonQuery::white;
      else if (strcmp(tmp, "BLACK") == 0)
        m_the_skin = PersonQuery::black;
      else if (strcmp(tmp, "BROWN") == 0)
        m_the_skin = PersonQuery::brown;
      else if (strcmp(tmp, "YELLOW") == 0)
        m_the_skin = PersonQuery::yellow;
      else if (strcmp(tmp, "RED") == 0)
        m_the_skin = PersonQuery::red;
      else if (strcmp(tmp, "GREEN") == 0)
        m_the_skin = PersonQuery::green;
 
      m_fields |= input_data::skin;
      m_fields_set++;
   }
   else m_done = TRUE;
   return;
}


//------------------------------------------------------------------
// Get the query eye color 
//
// Colors are entered as string and translated to PersonQuery::COLOR
// enum values.  Only some of the enum values are legal for eye
// color, so only translate the ones allowed.
//------------------------------------------------------------------
void input_data::get_eyes()
{
   char  tmp[100];

   // Get the eye color string.
   *m_in_data >> tmp;

   // We got one, so translate it to the enum value and set the bit field.
   if (strlen(tmp) > 0)
   {
      if (strcmp(tmp, "BLACK") == 0)
        m_the_eyes = PersonQuery::black;
      else if (strcmp(tmp, "BROWN") == 0)
        m_the_eyes = PersonQuery::brown;
      else if (strcmp(tmp, "GREEN") == 0)
        m_the_eyes = PersonQuery::green;
      else if (strcmp(tmp, "BLUE") == 0)
        m_the_eyes = PersonQuery::blue;
      else if (strcmp(tmp, "GRAY") == 0)
        m_the_eyes = PersonQuery::gray;
      else if (strcmp(tmp, "VIOLET") == 0)
        m_the_eyes = PersonQuery::violet;
      else if (strcmp(tmp, "HAZEL") == 0)
        m_the_eyes = PersonQuery::hazel;
      else m_the_eyes = PersonQuery::unknown;
 
      m_fields |= input_data::eyes;
      m_fields_set++;
   }
   else m_done = TRUE;
   return;
}

//------------------------------------------------------------------
// Get the query other markings 
//
// Other markings are entered as strings and translated to
// PersonQuery::MARKINGS enum.
//------------------------------------------------------------------
void input_data::get_other()
{
   char  tmp[100];

   // Get the 'other' string token.
   *m_in_data >> tmp;

   // We got one, so translate to the enum value and set the bit field.
   if (strlen(tmp) > 0)
   {
      if (strcmp(tmp, "TATTOO") == 0)
        m_the_other = PersonQuery::tattoo;
      else if (strcmp(tmp, "SCAR") == 0)
        m_the_other = PersonQuery::scar;
      else if (strcmp(tmp, "LIMB") == 0)
        m_the_other = PersonQuery::missing_limb;
      else if (strcmp(tmp, "NONE") == 0)
        m_the_other = PersonQuery::none;
      else m_the_other = PersonQuery::dont_care;
 
      m_fields |= input_data::other;
      m_fields_set++;
   }
   else m_done = TRUE;
   return;
}


//------------------------------------------------------------------
// Get the result
//
// The result command has no value field.
//------------------------------------------------------------------
void input_data::get_result()
{
   m_fields |= input_data::result;
   return;
}


//------------------------------------------------------------------
// Get the exit 
//
// The exit command has no value field.
//------------------------------------------------------------------
void input_data::get_exit()
{
   m_fields |= input_data::exit;
   return;
}


//------------------------------------------------------------------
// Display the user interface options
//------------------------------------------------------------------
void input_data::display_options()
{
    cout << "Options: " << endl;
    cout << "\tname \"<string>\"" << endl;
    cout << "\taddress \"<string>\"" << endl;
    cout << "\tss \"<string>\"" << endl;
    cout << "\tsex [male|female|cant_tell]" << endl;
    cout << "\tage <integer value>" << endl;
    cout << "\tmarriage [not_known|single|married|divorced]" << endl;
    cout << "\thobby [who_cares|rock|swim|tv|stamps|photo|weaving]" << endl;
    cout << "\tdob <mm/dd/yyyy>" << endl;
    cout << "\tht <integer value>" << endl;
    cout << "\twt <integer value>" << endl;
    cout << "\thair [white|black|brown|yellow|red|green|blue|gray|unknown]" << endl;
    cout << "\tskin [white|black|brown|yellow|red|green]" << endl;
    cout << "\teyes [black|brown|green|blue|gray|violet|hazel]" << endl;
    cout << "\tother [tattoo|scar|limb|none]" << endl;
    cout << "\tresult" << endl;
    cout << "\texit" << endl;
    cout << endl;

}

//--------------------------------------------------------------------
//  Utility function to construct a multiple data field request
//  
//  Queries that contain a single data item (such as hair color) are
//  converted into operations specific to the data item.  This function
//  converts multiple data item queries into the operation that processes
//  multiple data items.
//
//  Each type of data item has a special "dont care" value, which is used
//  to initialize the operation parameter for the "uninteresting" items 
//--------------------------------------------------------------------
static void build_multiple_data(input_data *in, PersonQuery::Person &query)
{
   /*
    * Construct a Person data structure by going thru the fields of the
    * input and initializing the Person from the input data.  Set the
    * fields for which no data was entered to their dontcare values.
    *
    * Copy all strings, because the CORBA::String_var class handles freeing
    * its own copy.  When it goes out of scope, we might still be using
    * the string in another function.
    */

   if (in->fields() & input_data::name)
   {
      query.name = CORBA::string_dup(in->m_the_name);
      if (!query.name)
         throw CORBA::NO_MEMORY();
   }
   else query.name = (char *) 0;

   if (in->fields() & input_data::ss)
   {
      query.ss = CORBA::string_dup(in->m_the_ss);
      if (!query.ss)
         throw CORBA::NO_MEMORY();
   }
   else query.ss = (char *) 0;

   if (in->fields() & input_data::age)
      query.age = in->m_the_age;
   else query.age = 0; 

   if (in->fields() & input_data::mar)
      query.mar = in->m_the_mar;
   else query.mar = PersonQuery::not_known; 

   if (in->fields() & input_data::rec)
      query.rec = in->m_the_rec;
   else query.rec = PersonQuery::who_cares; 

   if (in->fields() & input_data::sex)
      query.sex = in->m_the_sex;
   else query.sex = PersonQuery::cant_tell; 

   if (in->fields() & input_data::dob)
      query.dob = in->m_the_dob;
   else {
      query.dob.month = PersonQuery::Empty;
      query.dob.day = 0;
      query.dob.year = 0;
   }

   if (in->fields() & input_data::address)
   {
      query.addr.number = in->m_the_address.number;
      query.addr.street = CORBA::string_dup(in->m_the_address.street.in());
      if (!query.addr.street)
         throw CORBA::NO_MEMORY();
      query.addr.town = CORBA::string_dup(in->m_the_address.town.in());
      if (!query.addr.town)
         throw CORBA::NO_MEMORY();
      query.addr.state = CORBA::string_dup(in->m_the_address.state.in());
      if (!query.addr.state)
         throw CORBA::NO_MEMORY();
      query.addr.country = CORBA::string_dup(in->m_the_address.country.in());
      if (!query.addr.country)
         throw CORBA::NO_MEMORY();
   }
   else {
      query.addr.number = 0;
      query.addr.street = (char *)0;
      query.addr.town = (char *)0;
      query.addr.state = (char *)0;
      query.addr.country = (char *)0;
   }

   if (in->fields() & input_data::ht)
      query.ht = in->m_the_ht;
   else query.ht = 0;

   if (in->fields() & input_data::wt)
      query.wt = in->m_the_wt;
   else query.wt = 0;

   if (in->fields() & input_data::hair)
      query.hair = in->m_the_hair;
   else query.hair = PersonQuery::dontcare;

   if (in->fields() & input_data::eyes)
      query.eyes = in->m_the_eyes;
   else query.eyes = PersonQuery::dontcare;

   if (in->fields() & input_data::skin)
      query.skin = in->m_the_skin;
   else query.skin = PersonQuery::dontcare;

   if (in->fields() & input_data::other)
      query.other = in->m_the_other;
   else query.other = PersonQuery::dont_care;

}

//--------------------------------------------------------------------
// utility function to drive the application 
//
// This function performs the guts of this application.  It gets the
// input from the user, using an instance of the input_data class, and
// constructs the CORBA request. 
//--------------------------------------------------------------------
static void main_menu(
    PersonQuery_ptr query_ref
)
{

    PersonQuery::Possibles  *hits = 0;
    int   done = FALSE;
    int   ret_val = FALSE;

    // Get an instance of the input processing class.
    input_data * in  = new input_data();
    if (!in)
       throw CORBA::NO_MEMORY();

    // Loop, allowing the user to enter as many commands as they like
    // during this session. We exit this loop when the "exit" command
    // is found.
    while (!done)
    {
        // Get the input and parse the command into a data fields.
        try {
          in->get_input(); 
        } CATCH_REPORT_AND_SWALLOW_EXCEPTION;

        ret_val = FALSE;

        //  Determine which operation to call, depending upon the
        //  data that was entered.

        if (in->get_fields_set() > 1)
        {
           //
           // the exit and result commands are not allowed when the
           // user enters multiple data items.  So, if we get here,
           // delete any previous hits.
           //
           if (hits)
           {
              delete hits;
              hits = 0;
           }

           // multiple data fields entered for this query. Construct
           // a generic request and invoke.
           PersonQuery::Person query;
           try {
             build_multiple_data(in, query);
             ret_val = query_ref->findPerson(query, hits);
           } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
           if (ret_val)
              cout << "hits: " << hits->length() << endl;
           else cout << "no matches for query" << endl;
                
        }
        else {
           //
           // the "result" command should display the last query
           // made, however, if we are about to go make another query,
           // delete the last one made.
           //
           
           if (!(in->fields() & input_data::result))
           {
               if (hits)
                 delete hits;
               hits = 0;
           }

           // a single data item was entered for this query.  Figure
           // out what it is and call that operation, passing the
           // appropriate data member of the input_data class.
           if (in->fields() & input_data::name)
           {
               try {
                 ret_val = query_ref->findPersonByName(in->m_the_name, hits); 
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::address)
           {
               try {
                  ret_val = query_ref->findPersonByAddress(in->m_the_address, hits);  
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::ss)
           {
               try {
                  ret_val = query_ref->findPersonBySS(in->m_the_ss, hits);  
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::sex)
           {
               try {
                  ret_val = query_ref->findPersonBySex(in->m_the_sex, hits);  
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::age)
           {
               try {
                  ret_val = query_ref->findPersonByAge(in->m_the_age, hits); 
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::mar)
           {
               try {
                  ret_val = query_ref->findPersonByMarriage(in->m_the_mar, hits);  
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::rec)
           {
               try {
                  ret_val = query_ref->findPersonByHobby(in->m_the_rec, hits); 
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::dob)
           {
               try {
                  ret_val = query_ref->findPersonBydob(in->m_the_dob, hits);
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::ht)
           {
               try {
                  ret_val = query_ref->findPersonByHeight(in->m_the_ht, hits);     
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::wt)
           {
               try {
                  ret_val = query_ref->findPersonByWeight(in->m_the_wt, hits); 
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::hair)
           {
               try {
                  ret_val = query_ref->findPersonByHairColor(in->m_the_hair, hits);      
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::skin)
           {
               try {
                  ret_val = query_ref->findPersonBySkinColor(in->m_the_skin, hits); 
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::eyes)
           {
               try {
                  ret_val = query_ref->findPersonByEyeColor(in->m_the_eyes, hits); 
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::other)
           {
               try {
                  ret_val = query_ref->findPersonByOther(in->m_the_other, hits);   
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               if (ret_val)
                  cout << "hits: " << hits->length() << endl;
               else cout << "no matches for query" << endl;
           }
           else if (in->fields() & input_data::result)
           {
               try {
                 displayHits(hits);   
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
           }
           else if (in->fields() & input_data::exit)
           {
               done = TRUE;
               try {
                  query_ref->exit();   
               } CATCH_REPORT_AND_SWALLOW_EXCEPTION;
               cout << "Exiting..." << endl;
               if (hits)
                 delete hits;
           }
        }
    }
    delete in;
}


//
// This function gets the PersonQuery object reference.  It handles the
// interactions with the environmental objects.
//
static PersonQuery_ptr get_query(
    Tobj_Bootstrap&        bootstrap
)
{
    // Use the bootstrap object to find the factory finder :
    CORBA::Object_var v_fact_finder_oref =
        bootstrap.resolve_initial_references("FactoryFinder");

    // Narrow the factory finder :
    Tobj::FactoryFinder_var v_fact_finder_ref =
        Tobj::FactoryFinder::_narrow(v_fact_finder_oref.in());

    // Use the factory finder to find the
    // query factory :
    CORBA::Object_var v_query_fact_oref =
        v_fact_finder_ref->find_one_factory_by_id(
            _tc_QueryFactory->id()
        );

    // Narrow the factory :
    QueryFactory_var v_query_fact_ref =
        QueryFactory::_narrow(v_query_fact_oref.in());

    // Return the person query object :
    return v_query_fact_ref->createQuery(PersonQuery::_get_interface_name());
}


//--------------------------------------------------------------------

int main(int argc, char* argv[])
{

    try {
        // Initialize the ORB :
            CORBA::ORB_var v_orb = CORBA::ORB_init(argc, argv, "");

        // Create the bootstrap object:
        Tobj_Bootstrap bootstrap(v_orb.in(), "");

        // Get the PersonQuery object reference.
        PersonQuery_var v_reg_ref =
            get_query(bootstrap);

        // Go do the real work :
        main_menu(v_reg_ref.in());

    } CATCH_REPORT_AND_SWALLOW_EXCEPTION;

    return 0;
}		/*  End of main  */

